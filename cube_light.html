<html>
   <script id="vshader" type="x-shader/x-vertex">
        attribute vec3 a_position;
        attribute vec3 a_normal;
        
        uniform mat4 u_modelView;
        uniform mat4 u_worldNormal;
        uniform mat4 u_worldViewProjection;
        uniform vec3 u_lightWorldPosition;
        uniform vec3 u_viewWorldPosition;

        varying vec3 v_normal;
        varying vec3 v_surfaceToLight;
        varying vec3 v_surfaceToView;

        void main(){
            gl_Position = u_worldViewProjection * vec4(a_position, 1.0);
            v_normal = (u_worldNormal * vec4(a_normal, 1.0)).xyz;
            vec3 surfaceWorldPosition = (u_modelView * vec4(a_position, 1.0)).xyz;
            v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
            v_surfaceToView = u_viewWorldPosition -surfaceWorldPosition;
        }
    </script>

    <script id="fshader" type="x-shader/x-fragment">
        precision mediump float;

        varying vec3 v_normal;
        varying vec3 v_surfaceToLight;
        varying vec3 v_surfaceToView;
        
        uniform vec4 u_color;
        uniform float u_shininess;
        void main(){
            vec3 normal = normalize(v_normal);
            vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
            vec3 surfaceToViewDirection = normalize(v_surfaceToView);
            vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
            float specular = 0.0;
            float light = max(dot(normal, surfaceToLightDirection), 0.0);
            specular = pow(max(dot(normal, halfVector), 0.0), u_shininess);
            gl_FragColor = u_color;
            gl_FragColor.rgb *= light;
            gl_FragColor.rgb + = specular;
        } 
    </script>
    <script src="./readerShader.js"></script>
    <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
   
   
    <body>
        <canvas id="canvas"></canvas>
    </body>
    <script>
        /**
         *  realize a base cube with different light and rotate 
         *  add texture 
         **/
        var width = 800, height = 600;
        function init(){
            var canvas = document.getElementById("canvas");
            var gl = canvas.getContext("webgl");
            
            if(!gl) return ;
            gl.viewport(0, 0, width, height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            return gl;
        }
        function initShader(gl){
            var vertexShader = getShader(gl, "vshader");
            var fragmentShader = getShader(gl, "fshader");
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            
            gl.linkProgram(program);
            gl.useProgram(program);

            var vertexLoc = gl.getAttribLocation(program, "a_position");
            var normalLocation = gl.getAttribLocation(program, "a_normal")
            var modelViewLocation = gl.getUniformLocation(program, "u_modelView");
            var worldViewProjectionLocation = gl.getUniformLocation(program, "u_worldViewProjection");
            var worldInverseTransposeLocation = gl.getUniformLocation(program, "u_worldNormal");
            var viewWorldPostionLocation = gl.getUniformLocation(program, "u_viewWorldPosition");
            var lightWorldPositionLocation = gl.getUniformLocation(program, "u_lightWorldPosition");
            var colorLocation = gl.getUniformLocation(program, "u_color");
            var shininessLocation = gl.getUniformLocation(program, "u_shininess");
            
            var positinBuffer = gl.createBuffer();
            gl.enableVertexAttribArray(vertexLoc);
            gl.bindBuffer(gl.ARRAY_BUFFER, positinBuffer);
            gl.vertexAttribPointer(vertexLoc, 3, gl.FLOAT, false, 0, 0);

            var normalBuffer = gl.createBuffer();
            gl.enableVertexAttribArray(normalLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
            
            var positions = new Float32Array([
               0, 0, 0,
               20, 0, 0,
               20, 20, 0,
               0, 20, 0,
               0, 20, 10,
               0, 0, 10,
               20, 0, 10,
               20, 20, 10
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            var normals = new Float32Array([
                // back
                0, 0, -1,
                0, 0, -1,
                0, 0, -1,
                
                0, 0, -1,
                0, 0, -1,
                0, 0, -1,

                // left
                -1, 0, 0,
                -1, 0, 0,
                -1, 0, 0,

                -1, 0, 0,
                -1, 0, 0,
                -1, 0, 0,

                // bottom 
                0, -1, 0,
                0, -1, 0,
                0, -1, 0,

                0, -1, 0,
                0, -1, 0,
                0, -1, 0,

                // right
                1, 0, 0,
                1, 0, 0,
                1, 0, 0,

                1, 0, 0,
                1, 0, 0,
                1, 0, 0,

                // top
                0, 1, 0,
                0, 1, 0,
                0, 1, 0,

                0, 1, 0,
                0, 1, 0,
                0, 1, 0,
                
                // up
                0, 0, 1,
                0, 0, 1,
                0, 0, 1,

                0, 0, 1,
                0, 0, 1,
                0, 0, 1
            ]);
            
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
            
            var indices = new Float32Array([
                0, 1, 2,
                2, 3, 0,
                0, 3, 4,
                4, 5, 0,
                0, 5, 6,
                6, 1, 0,
                1,6, 7,
                7, 2, 1,
                7,4,3,
                3,2,7,
                4,7,6,
                6,5,4
            ]);
            gl.bufferData(gl.ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            modelMatrix = mat4.create();
            
        }
        function degToRad(degrees) {
            return  degrees * Math.PI /180;
        }
        var width, height;
        function draw(){
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // compute projection matrix
            var aspect = width / height;
            var zNear = 1;
            var zFar = 2000;
            var projectionMatrix = mat4.create();

            mat4.perspetive(45, apsect, zNear, zFar, projectionMatrix);

            var cameraPosition = [0, 0, -50];
            var target = [0, 0, 0];
            var up = [0, 1, 0];
            var cameraMatrix = mat4.lookAt(cameraPosition, target, up);
            mat4.multiply(projectionMatrix, cameraMatrix);
            
            // mat4.identity()
            mat4.rotate(modelMatrix, degToRad(10), [1, 0, 0]);
            mat4.rotate(modelMatrix, degToRad(currentAngle), [0, 1, 0]);

            var modelviewInv = mat4.create();
            mat4.set(modelMatrix, modelviewInv);
            mat4.inverse(modelviewInv);
            
            var normalmatrix = mat4.create();
            mat4.set(modelView, normalmatrix);
            mat4.inverse(normalmatrix);
            mat4.transpose(normalmatrix);
            
            var shininess = 10;
            gl.uniformMatrix3f(viewWorldPostionLocation, cameraPosition);
            gl.uniformMatrix4fv(modelViewLocation, false, modelMatrix);
            gl.uniformMatrix4fv(worldViewProjectionLocation, false, projectionMatrix);
            gl.uniformMatrix4fv(worldInverseTransposeLocation, false, modelviewInv);
            gl.uniformMatrix4fv(normalLocation, false, normalmatrix);
            gl.uniformMatrix1f(shininessLocation, shininess);
            gl.uniformMatrix3f(lightWorldPositionLocation, [30, 10, 30]);
            var color = [1.0, 0.0, 1.0];
            gl.uniformMatrix4f(colorLocation, color[0], color[1], color[2]);
            
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            
        }
        (function (){
            var gl = init();
            initShader(gl);
            requestAnimationFrame(draw);
        })();
    </script>
</html>